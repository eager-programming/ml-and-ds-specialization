Вырезано из https://www.coursera.org/learn/supervised-learning/lecture/k2VxN/rieghuliarizatsiia 

Интерактивный текст видеоматериала 

[ЗАСТАВКА] В этом видео  

мы поговорим про регуляризацию — способ борьбы с переобучением в линейных моделях.  

В прошлый раз мы с вами убедились, что мерой сложности или симптомом  

переобученности линейной модели являются большие веса при признаках.  

Например, когда мы пытались обучить полином 9-й степени под вот такую выборку,  

мы получали переобученную модель,  

коэффициенты которой были огромными — миллионы и десятки миллионов.  

Еще одна ситуация,  

в которой можно столкнуться с переобучением — это мультиколлинеарность.  

Так называется проблема, при которой признаки выборки являются линейно  

зависимыми, то есть есть некоторый вектор значений признака на всех объектах,  

который выражается через векторы других признаков.  

Или, иными словами, это означает, что существуют такие веса α1,  

..., αd, что какой бы объект обучающей выборки xi мы не взяли,  

оказывается, что если мы просуммируем с этими коэффициентами все  

значения признаков на этом объекте xi, получим 0.  

Это, по сути, есть определение линейной зависимости.  

Более компактно это можно записать как равенство нулю скалярного  

произведения вектора коэффициентов α на вектор признаков xi.  

Итак, в чем проблема мультиколлинеарности?  

Давайте представим, что мы решаем некоторую оптимизационную задачу,  

например минимизируем среднеквадратичную ошибку,  

то есть средний квадрат отклонения прогноза от истинного ответа yt.  

И нашли оптимальную точку w* — точку,  

на которой достигается минимум этого функционала.  

Хорошо, а теперь давайте возьмем этот оптимальный вектор весов w* и прибавим  

к нему тот вектор коэффициентов α из определения линейной зависимости  

с некоторым множителем t, скалярным множителем.  

И давайте посмотрим, как будет выглядеть прогноз алгоритма с  

этим новым модифицированным вектором весов на некотором объекте x.  

Для этого нужно посчитать скалярное произведение вектора w* + tα на вектор x.  

По правилам скалярного произведения это выражение распадается на  

сумму двух скалярных произведений.  

Первое — это w* умножить на x,  

второе — это α умножить на x с некоторым скалярным множителем t.  

Но при этом давайте вспомним, что α умножить на x скалярное — это 0,  

просто по определению линейной зависимости.  

Получаем, что прогноз нашего модифицированного алгоритма равен w*  

умножить на x, то есть прогнозу исходного оптимального алгоритма.  

Значит, мы получили новый алгоритм с новым векторов весов,  

который во всем совпадает с исходным алгоритмом.  

Получается, что и значение функционала качества, функционала ошибки на этом  

алгоритме будет такое же — он тоже будет оптимальным.  

Итак, в случае с мультиколлинеарностью у нас бесконечно много оптимальных  

алгоритмов, при этом многие из них будут иметь очень большие значения весов,  

но далеко не все из них хорошо обобщают информацию,  

обладают хорошей обобщающей способностью.  

Поэтому здесь тоже легко столкнуться с переобучением.  

Итак, мы выяснили,  

что симптомом переобучения являются большие веса в линейной модели  

— давайте будем штрафовать за это модель, чтобы бороться с переобучением.  

Делать это будем с помощью регуляризатора.  

Итак, допустим, есть некоторый функционал ошибки Q, которому на вход подаются,  

напомню, векторы весов w и выборка x.  

Будем прибавлять к нему квадратичный регуляризатор,  

то есть L2 — норму вектора весов, или просто сумму квадратов весов.  

И теперь заменим функционал ошибки на следующий: он  

будет представлять собой сумму исходного функционала Q и регуляризатора с  

некоторым коэффициентом λ.  

И будем минимизировать эту сумму.  

Ее минимизация приведет к тому, что мы хотим одновременно сделать ошибку на  

обучающей выборке как можно меньше, то есть минимизировать Q,  

но и при этом не слишком сильно увеличить веса при признаках,  

то есть не слишком сильно увеличить норму весов w.  

При этом у нас появляется новый параметр в модели — коэффициент регуляризации λ,  

который стоит перед своим регуляризатором.  

Чем больше мы делаем λ, тем менее сложные модели будут получаться.  

Если мы будем увеличивать λ все сильнее и сильнее, то в какой-то момент окажется,  

что оптимально просто занулить все веса, сделать их нулевыми.  

То есть слишком большая λ приведет к слишком простой константной модели.  

В то же время если λ делать маленькой, то есть риск переобучения, риск,  

что модель окажется слишком сложной.  

Таким образом, нужно искать некоторый баланс — выбирать λ такой, что,  

с одной стороны, она не допускает переобучения, с другой — позволяет делать  

модель достаточно сложной, чтобы уловить все закономерности в данных.  

Обычно λ подбирается по кросс-валидации, о которой будем говорить в следующем видео.  

А пока давайте выясним, какой смысл имеет добавление регуляризатора.  

Оказывается, что наша новая задача — Q + λ умножить на регуляризатор,  

и это мы минимизируем — эквивалентна условной задаче оптимизации,  

которая выглядит следующим образом.  

Мы минимизируем исходный функционал ошибки Q при ограничении.  

А ограничение состоит в том,  

что норма вектора весов не должна превосходить некоторую константу C.  

Получается, что мы решаем исходную задачу, но при этом ограничиваем по норме векторы  

весов, ровно то, что мы и хотели делать — штрафовать за слишком большую норму весов.  

Геометрически это означает, что если у нас есть некоторый функционал ошибки, который  

выпуклый и его линии уровня выглядят как-то вот так, то без регуляризатора мы  

бы просто искали минимум этого функционала — находили минимальную точку.  

После же добавления регуляризатора мы требуем,  

чтобы и решение находилось внутри некоторой круглой области с центром в 0.  

И теперь мы находим такое решение, которое находится внутри этой  

области и при этом как можно ближе к оптимальному решению без регуляризатора.  

Пока что мы говорили только про L2-регуляризатор — сумму квадратов весов.  

Он штрафует за сложность модели, и позволяет бороться с переобучение,  

и при этом является гладким и выпуклым, то есть его добавление к функционалу не будет  

усложнять процесс оптимизации, например, градиентный спуск.  

Но также есть L1-регуляризатор, который представляет собой L1-норму вектора весов,  

или просто сумму модулей весов.  

Он не является гладким — модуль не имеет производной в 0,  

то есть оптимизация функционала с таким регуляризатором будет затруднительна,  

но при этом такой регуляризатор обладает очень интересным свойством.  

Если использовать его, то часть весов в итоговом векторе весов будут нулевыми,  

то есть он производит отбор признаков — использует в модели не все признаки,  

а только самые важные из них.  

Это очень интересное свойство, которое часто пригождается на практике.  

Итак, мы обсудили,  

что большие веса в линейных моделях — это симптом переобучения.  

И для борьбы с этим переобучением можно пытаться «задавить» симптом,  

то есть штрафовать за слишком большие значения весов.  

Это можно делать с помощью L2-регуляризации,  

которая является самым частым выбором и штрафует за сложность модели.  

Или с помощью L1-регуляризации, которая чуть сложнее при оптимизации,  

но при этом позволяет отбирать признаки.  

В следующем видео мы поговорим про то, что такое кросс-валидация,  

и как оценивать качество алгоритма на новых данных.  
