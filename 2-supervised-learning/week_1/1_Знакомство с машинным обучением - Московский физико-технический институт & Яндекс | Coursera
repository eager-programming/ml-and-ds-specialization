Вырезано из https://www.coursera.org/learn/supervised-learning/lecture/4NQgT/znakomstvo-s-mashinnym-obuchieniiem 

Интерактивный текст видеоматериала 

[ЗАСТАВКА] Здравствуйте.  

Меня зовут Евгений Соколов,  

и я рад приветствовать вас на курсе «Обучение на размеченных данных».  

Это второй курс специализации «Машинное обучение и анализ данных»,  

в котором мы начнем знакомиться, собственно, с машинным обучением.  

Центральной темой этого курса является обучение с учителем.  

На самом деле, мы немного затрагивали эту тему,  

когда говорили про интерполяцию в прошлом курсе.  

Интерполяция — это значит восстановление функции по нескольким точкам,  

в которых известны ее значения.  

Обучение с учителем — это тоже восстановление общей закономерности  

по конечному числу примеров.  

Хотя постановки задач похожи, у них есть много отличий в том,  

как они решаются и какие требования выдвигаются к решению.  

Мы будем обсуждать эти различия в нашем курсе.  

Давайте разберем не очень сложный пример, на котором поймем,  

в чем заключается обучение с учителем и машинное обучение.  

Представьте, что у нас есть некоторый сайт про фильмы, на который можно зайти,  

найти страницу нужного фильма, почитать про него, когда он снят, кто в нем играет,  

какой бюджет был у этого фильма и, возможно, даже купить его и посмотреть.  

И есть некоторый пользователь, который заходит на наш сайт,  

находит страницу нужного ему фильма, читает и задается вопросом,  

смотреть или не смотреть, интересен ему этот фильм или не интересен.  

И мы хотим понять это за него.  

Как это можно сделать?  

Есть несколько подходов к решению.  

Подход первый, самый глупый — это дать пользователю посмотреть этот фильм.  

Понятно, что он потратит 1,5–2 часа, фильм может не понравится, он будет недоволен.  

Подход второй — показывать ему случайную рекомендацию.  

То есть говорить понравится или не понравится просто из генератора  

случайных чисел.  

Подход тоже не самый лучший: пользователь может смотреть фильм,  

он опять ему не понравится, и он будет недоволен нашим сайтом.  

Наконец, можно пригласить психолога-киномана разрешить ситуацию.  

Этот человек оценит пользователя, поймет, что ему нравится, а что — нет,  

оценит фильм, вспомнит про него всё и поймет, кому он может нравиться,  

сопоставит эту информацию и выдаст пользователю рекомендацию,  

смотреть или не смотреть.  

Этот подход довольно сложный.  

Скорее всего, таких специалистов не очень много в мире,  

и будет сложно отмасштабировать это на миллионы пользователей нашего сайта.  

Но на самом деле это и не нужно.  

Давайте поймем, что у нас много примеров, много ситуаций, когда другие пользователи  

заходили на страницу фильмов, принимали решение посмотреть фильм и дальше ставили  

оценку, по которой можно понять, понравилось им или не понравилось.  

Это примеры, та информация, из которой можно восстановить общую зависимость.  

В этом и заключается задача машинного обучения.  

Давайте введем пару обозначений, которыми мы будем пользоваться в нашем курсе.  

Машинное обучение — это раздел математики, поэтому в нем, конечно же,  

есть место формулам.  

Объектом будем называть то, для чего нужно сделать предсказание.  

В нашем примере объектом является пара, состоящая из пользователя и фильма,  

и для нее нужно предсказать, понравится ли этот фильм этому пользователю.  

Объекты будем обозначать маленькой буквой x.  

Далее, пространство объектов — это множество всех возможных объектов,  

для которых может понадобиться делать предсказание.  

В нашем случае это множество всех возможных пар «пользователь-фильм».  

Пространство объектов будем обозначать буквой x красивое.  

Ответом будем называть то, что нужно предсказать.  

В нашем случае ответ — это понравится пользователю фильм или не понравится.  

Обозначать ответы будем маленькой буквой y.  

Наконец, пространство ответов — это множество всех возможных ответов,  

с которыми мы можем работать.  

В нашем примере это множество состоит из двух элементов: −1 и +1.  

−1 означает, что пользователю фильм не понравился, +1 означает,  

что пользователю фильм понравился.  

Обозначать пространство ответов будем буквой y красивое.  

Как мы уже выясняли с вами в прошлом курсе,  

объекты — это сущности из реального мира, а компьютер не понимает,  

что это такое, он не знает, что такое пользователь или фильм, ему нужно  

объяснить эти объекты с помощью чисел, которые компьютер уже может понимать.  

Признак — это некая числовая характеристика объекта, а совокупность  

всех признаков, которых d штук, называется признаковым описанием объекта.  

Кстати, хотя я говорю, что признак — это число, мы с вами увидим,  

что есть и другие случаи, когда признак — это элемент множества,  

или строка, или что-то еще, но всё это — нечто, понятное компьютеру.  

Признаковое описание — это d-мерный вектор и можно с ним работать как с вектором,  

складывать, умножать на числа и так далее,  

то есть это — некий объект линейной алгебры.  

В нашем примере признаки могут быть самые разные: прошлые оценки этого пользователя  

другим фильмам; его анкетные данные; оценки,  

которые другие пользователи ставили этому фильму и так далее.  

Центральным понятием машинного обучения является обучающая выборка.  

Это то, это те примеры, на основе которых мы будем строить общую закономерность.  

Обучающая выборка обозначается большой буквой X и состоит из l  

пар объектов и ответов.  

xi-тое — это i-тый объект обучающей выборки,  

yi-тое — это истинный ответ на нем, то, что нужно предсказать.  

Иногда отдельный большой вопрос — это как собрать обучающую выборку,  

откуда ее взять.  

В нашем случае это довольно просто: она будет состоять из прошлых событий,  

когда пользователь оценивал какой-то фильм.  

Наконец, нам нужно что-то, что будет делать предсказания, что-то,  

что поможет нам решать нашу задачу с фильмами и пользователями.  

Это называется алгоритмом или моделью и обозначается a(x).  

Это, по сути, функция, которая переводит объекты в ответы,  

которая отображает пространство объектов в пространство ответов.  

a(x) принимает на вход, собственно, объект x.  

Кстати, слово «алгоритм» обозначает,  

что эта функция должна быть легко реализуема на компьютере,  

что ее должно быть легко использовать в системах машинного обучения.  

Простым примером алгоритмов являются линейные алгоритмы,  

о которых мы тоже говорили в прошлом курсе.  

Идея линейных алгоритмов очень простая: давайте возьмем все  

признаки и сложим их с некоторыми весами, и еще прибавим некоторую,  

некоторый константный коэффициент w0.  

Поскольку такая линейная комбинация признаков — это, по сути,  

любое вещественное число, а в нашей задаче ответов всего два, −1 и +1, понравился  

фильм или не понравился, то нужно взять знак от этой суммы, то есть для задачи  

классификации, для задачи определения понравится фильм или не понравился,  

алгоритм будет иметь вид знака от линейной комбинации всех признаков объекта.  

Давайте поймем,  

что не все алгоритмы одинаково подходят для решения нашей задачи.  

Например, рассмотрим константный алгоритм a(x) = 1.  

Алгоритм, который для всех пар «пользователь-фильм» говорит,  

что фильм этому пользователю понравится.  

Понятно, что это довольно бесполезный алгоритм, который вряд ли принесет пользу  

нашему сайту, поэтому нам нужно ввести некоторую характеристику полезности,  

характеристику качества алгоритма для данной конкретной задачи.  

Эта характеристика называется функционалом ошибки и обозначается как Q.  

Q принимает на вход алгоритм и выборку и возвращает некоторую характеристику того,  

насколько хорошо работает данный алгоритм на данной выборке.  

В нашем случае это может быть, например, доля неправильных ответов,  

то есть берем всю выборку x и смотрим, на какой доле пар «пользователь-  

фильм» наш алгоритм ошибся, выдал неправильное предсказание.  

Понятно, что чем меньше будет такая доля неверных ответов, тем лучше.  

Обратите внимание на еще один факт: функция Q называется функционалом ошибки,  

а не функцией.  

Функционал, потому что она принимает на вход другую функцию,  

алгоритм является функцией, как вы помните.  

Итак, задача обучения состоит в подборе такого алгоритма a,  

на котором достигается минимум функционала ошибки.  

Сразу возникает вопрос: а из какого множества нужно выбирать лучший алгоритм?  

Для этого вводится понятие семейства алгоритмов,  

которое обозначается буквой A красивое.  

По сути, это множество всех алгоритмов, среди которых мы будем искать лучший, тот,  

который лучше всего подходит для решения нашей задачи,  

которая составляет минимум к функционалу ошибки.  

Простейшим примером семейства алгоритмов являются решающие пни.  

Каждый решающий пень делает очень простую вещь: он берет некоторый  

один фиксированный признак xj-тое и сравнивает его значение на данном  

объекте с некоторым порогом t.  

Если значение признака меньше этого порога, то алгоритм возвращает ответ −1,  

говорит, что этому пользователю фильм не понравится.  

Если же значение j-того признака больше или равно порога t,  

то алгоритм дает ответ +1, говорит, что пользователю фильм понравится.  

Это очень простые алгоритмы, они могут проверять только очень простые факты  

вроде «Пользователь посмотреть больше трех комедий».  

Понятно, что здесь нужно проверять более сложные, парные взаимодействия, например,  

«Пользователь посмотрел больше трех комедий» и «Данный  

фильм является комедией».  

Но решающие пни на это не способны,  

для этого нужны более сложные семейства алгоритмов.  

Тем не менее, решающие пни пригодятся нам в этом курсе для составления сложных  

композиций алгоритмов.  

Обратите внимание на одно обозначение, которое используется на этом слайде.  

Это квадратные скобки, скобки Айверсона или нотация Айверсона.  

Внутри скобок Айверсона находится некое логическое выражение, например,  

«значение j-того признака меньше порога t».  

Если это выражение — верное, то значение скобок равно 1,  

если же значение неверное, то значение скобок равно 0.  

Итак, чтобы заниматься машинным обучением,  

нужно уметь отвечать на три вопроса: как измерять качество,  

какой функционал ошибки использовать в данной задаче; какое взять семейство  

алгоритмов, из чего выбирать оптимальный алгоритм для данной задачи; и,  

наконец, как этот выбор производить, как делать обучение алгоритма?  

При этом есть ряд других вопросов, которые не менее важны,  

но относятся скорее к анализу данных, а не к машинному обучению.  

Анализ данных — это более широкая область науки, которая включает в себя множество  

различных эвристик, очень полезных для этой работы.  

Например, как сформировать признаки, какие выбрать признаки, чтобы на них задача  

решалась лучше всего, или как готовить признаки, как их предобрабатывать,  

как они должны выглядеть, чтобы алгоритм хорошо обучался на них, или,  

например, какую выбрать метрику, чтобы алгоритм не только хорошо настраивался,  

но и приносил реальную экономическую пользу заказчику.  

В этом уроке мы поговорим о совсем базовых понятиях: о постановках  

задач машинного обучения и о том, какие признаки бывают машинного обучения.  

Это очень простые и базовые вещи, которые пока не имеют отношения к реальным  

задачам, но нам очень важно о них поговорить, чтобы использовать общую  

терминологию, говорить на одном языке, а уже в следующем уроке мы перейдем к  

реальным примерам и к реальным семействам алгоритмов, а именно к линейным.  
