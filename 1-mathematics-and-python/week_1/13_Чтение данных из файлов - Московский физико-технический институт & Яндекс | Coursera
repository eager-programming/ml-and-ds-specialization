Вырезано из https://www.coursera.org/learn/mathematics-and-python/lecture/8Xvwp/chtieniie-dannykh-iz-failov 

Video Player is loading. 

Play Video 

Loaded: 0% 

Progress: 0% 

Current Time 0:00 

/ 

Duration 11:27 

Субтитры 

Отключить субтитры 

Русский 

Качество видео 

Среднее 

Скорость воспроизведения 

1.00x 

Автозапуск 

This is a modal window. 

Beginning of dialog window. Escape will cancel and close the window. 

TextColorTransparencyBackgroundColorTransparencyWindowColorTransparency 

Font SizeText Edge StyleFont Family 

End of dialog window. 

Не удалось отправить. Повторите попытку.Пропустить 

На этом видео мы начнем  

говорить о работе с файлами в Python.  

Часто для анализа нам требуется использовать данные,  

хранящиеся в некотором внешнем файле.  

Это может быть электронная таблица, простой текстовый документ,  

html-документ — любой, доступный для хранения данных, формат.  

Для этого Python предоставляет нам целый ряд разнообразных инструментов.  

Мы с вами начнем с простого и изучим встроенную функцию open.  

Если вы встречаетесь с некоторой функцией в первый раз,  

то полезно почитать ее Docstring.  

Это делается с помощью вопросительного знака.  

Набираем вопросительный знак и имя функции — внизу экрана открывается Docstring.  

Мы можем увидеть, что функция принимает три аргумента: это name, mode и buffering.  

Нас будут интересовать первые два из них.  

Аргумент name отвечает за название файла, который мы хотим открыть.  

Если файл лежит в той же директории, что и IPython, то можно просто написать его имя.  

Если же он в другой директории, то придется прописать путь.  

Mode отвечает за то, каким образом мы хотим работать с файлом.  

Если мы не планируем делать никаких изменений, а, например,  

просто хотим прочитать содержимое файла или прочитать его в какой-то контейнер,  

то нам подойдет режим для чтения.  

В этом случае мы не сможем изменять сам файл,  

но тем не менее мы сможем его читать.  

Если мы хотим перезаписать существующий файл или записать новый,  

то нам нужен режим для записи.  

Если же мы хотим взять существующий файл и как-то его модифицировать,  

ну например добавить какие-то строчки в его конец,  

то нам подойдет режим append — режим для добавления данных в конец.  

Итак, мы с вами будем решать довольно простую задачу: мы возьмем файл,  

откроем его и выведем его содержимое на экран.  

Тогда нам подойдет режим для чтения.  

Итак, давайте зададим новый объект,  

назовем его file_object, и с помощью функции open откроем файл.  

[ПЕЧАТАЕТ] Далее,  

если мы хотим открывать файл в режиме для чтения, то нам необязательно  

указывать mode, потому что по умолчанию файл открывается в режиме для чтения.  

Но давайте мы его укажем, для того чтобы это было явно видно.  

Итак, мы создали наш объект, давайте теперь посмотрим, какой у него тип.  

Это делается с помощью команды type.  

Итак, мы видим, что тип нашего объекта действительно file.  

Теперь давайте выведем его на экран — это можно сделать с помощью функции read.  

[ПЕЧАТАЕТ] Мы видим,  

что наш файл состоит из трех строк, все эти строчки на русском языке.  

Часто нам бывает удобно считывать файл не полностью, а, например,  

считывать его по строкам.  

В частности, если у нас большой файл, нам бывает интересно просто почитать, как он  

начинается, прочесть несколько первых строк, а весь текст файла нам не нужен.  

В этом случае бывает удобно воспользоваться функцией readline.  

Для начала нам снова придется открыть файл для чтения.  

[ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ] А  

далее давайте вызовем функцию readline.  

[ПЕЧАТАЕТ] И видим,  

что у нас вывелась на экран только первая строка.  

А повторный вызов данной функции приведет к печати следующей строки.  

Давайте посмотрим.  

[ПЕЧАТАЕТ] Если  

продолжать процедуру, то мы таким образом можем дойти до конца файла.  

Вот вывод пустой строки на экран обозначает конец файла.  

Но, на самом деле, для того чтобы обращаться к файлу построчно,  

нам совсем необязательно пользоваться такими функциями,  

как read и readline — мы можем обращаться с файлом как с обычным генератором.  

Вот давайте посмотрим, как это выглядит.  

Снова откроем файл.  

[ПЕЧАТАЕТ] А дальше просто, с помощью цикла for,  

давайте этот файл обойдем и выведем на экран каждую его строчку.  

[ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ] Обращаю внимание,  

что мы используем здесь новую функцию — это функция strip.  

Она помогает отрезать нам от конца каждой строки пробельные символы — это могут быть  

пробелы, знаки табуляции, а также знаки переноса строки.  

Итак, вызываем функцию и видим, что наш файл также напечатался построчно.  

Часто мы хотим работать со строчками файла как с массивом.  

Что имеется в виду?  

У нас есть файл, который состоит из нескольких строк, и мы хотим создать  

список, каждый элемент которого соответствует отдельной строке файла.  

Часто это бывает удобно.  

Это также можно сделать несколькими способами.  

Первый способ самый простой — изменить тип объекта file на список и просто работать с  

ним как со списком.  

Давайте это сделаем.  

Создадим объект data_list — список, и просто с помощью  

команды list сделаем наш файл объектом типа «список».  

Снова открываем файл для чтения.  

[ПЕЧАТАЕТ] И  

получаем наш список.  

Теперь давайте выведем содержимое списка на экран, чтобы убедиться,  

что каждый элемент соответствует отдельной строчке.  

[ПЕЧАТАЕТ] [ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ] [ПЕЧАТАЕТ] Итак,  

видим, что результат снова нас удовлетворяет.  

Мы построчно вывели файл на экран.  

Второй способ — это использование функции readlines,  

она возвращает список строк нашего файла.  

[ПЕЧАТАЕТ] Уже  

привычным нам способом открываем файл.  

[ПЕЧАТАЕТ] И далее,  

с помощью функции readlines, создаем новый список.  

[ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ] Итак,  

список готов, теперь снова давайте его напечатаем.  

[ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ] Итак, готово.  

Соответственно, теперь вы можете выбирать тот способ, который вам больше нравится:  

использование функции readlines или просто работа с файлом как со списком.  

Когда мы закончили работу с файлом, файл нужно закрыть.  

Это делается с помощью команды close.  

Это полезно сразу по нескольким причинам.  

Первая причина — мы освобождаем ресурсы,  

которые используются системой на чтение и поддержку нашего файла.  

Вторая причина — это так называемая безопасная работа с файлом.  

После того как мы файл закрыли, мы уже не можем его читать,  

не можем вносить в него изменения.  

Таким образом, наш файл в какой-то степени защищен от каких-то незапланированных  

действий или ошибок.  

Давайте посмотрим, как это работает.  

Если мы сначала открыли файл, например, открываем его снова для чтения.  

Возьмем тот же самый файл.  

Дальше мы вызвали функцию, которая его закрывает — функция close.  

[ПЕЧАТАЕТ] И дальше,  

например, давайте попробуем его прочесть, после того как мы его закрыли.  

Это должно привести к ошибке, потому что мы пытаемся прочитать уже закрытый файл.  

И действительно, мы видим, что операция такая невозможна,  

потому что мы пытаемся прочитать закрытый файл.  

Итак, мы с вами уже научились читать файл и делать это несколькими способами.  

На самом деле, все это время мы работали с файлом в кодировке utf8,  

это можно было понять из названия.  

В жизни это не всегда так,  

и часто нам приходится работать с данными в разных кодировках.  

Давайте теперь попробуем открыть файл в кодировке koi_8-r — это русскоязычная  

кириллица.  

Для начала попробуем поступить аналогичным образом.  

Используем функцию open.  

Создаем объект file и пытаемся прочитать его, после чего — вывести его на экран.  

[ПЕЧАТАЕТ] Теперь  

вызываем метод read.  

[ПЕЧАТАЕТ] И видим,  

что наш файл выглядит не совсем так, как нам хотелось.  

Давайте добавим функцию print и убедимся в этом.  

Вот видите, появились какие-то не очень симпатичные символы.  

Это говорит о том, что у нас есть проблемы с этой кодировкой.  

Для того чтобы напечатать этот файл красиво, нужно каким-то образом указать,  

что мы используем кодировку utf8.  

Ну на самом деле, сделать это можно разными способами.  

Один из самых простых — это использовать библиотеку Codecs.  

Давайте на нее посмотрим.  

[ПЕЧАТАЕТ] Для начала ее нужно импортировать.  

Это делается с помощью ключевого слова import.  

[ПЕЧАТАЕТ] А теперь давайте читать файл.  

На самом деле, библиотека Codecs предоставляет нам похожую функцию open.  

У нее схожий синтаксис, только нам можно указать еще дополнительные параметры,  

например кодировку.  

Вот давайте это сделаем.  

Снова создадим объект file, назовем его file_object.  

И теперь уже с помощью функции open из модуля Codecs будем его читать.  

Передаем туда название файла.  

И теперь давайте добавим новый параметр encoding, или кодировка.  

[ПЕЧАТАЕТ] Так, файл мы прочли.  

Теперь давайте выведем его на экран, ожидая,  

что теперь у нас не будет проблем с выводом.  

[ПЕЧАТАЕТ] Итак,  

мы видим, что теперь файл выводится корректно.  

Это происходит, потому что мы открыли его в правильной кодировке.  

На этом мы заканчиваем знакомство с чтением данных.  

На следующем видео мы также будем говорить про работу с файлами,  

но уже будем учиться файл записывать.  
