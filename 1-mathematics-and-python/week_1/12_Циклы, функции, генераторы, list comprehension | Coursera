Вырезано из https://www.coursera.org/learn/mathematics-and-python/lecture/Kd7dL/tsikly-funktsii-ghienieratory-list-comprehension 

Video Player is loading. 

Play Video 

Loaded: 0% 

00:01 

Progress: 0% 

Current Time 0:00 

/ 

Duration 13:54 

Субтитры 

Отключить субтитры 

Русский 

Качество видео 

Среднее 

Скорость воспроизведения 

1.00x 

Автозапуск 

This is a modal window. 

Beginning of dialog window. Escape will cancel and close the window. 

TextColorTransparencyBackgroundColorTransparencyWindowColorTransparency 

Font SizeText Edge StyleFont Family 

End of dialog window. 

Не удалось отправить. Повторите попытку.Пропустить 

[БЕЗ_ЗВУКА] В  

этом видео мы познакомимся с некоторыми простыми конструкциями языка  

«Питон» и начнем привыкать к его синтаксису.  

Итак, давайте разберемся с условным оператором.  

Точно так же, как и в других языках программирования, здесь можно написать  

что-нибудь в духе… там… давайте заведем какую-то переменную… напишем,  

пусть она равна true, и напишем if x… print…  

ok… Если мы хотим рассмотреть другой случай,  

то пишем else: и что-нибудь еще.  

Проверяем.  

Да, все хорошо.  

Если сейчас поменяем на false, все работает так, как нужно.  

Теперь обратите внимание, если во многих других языках программирования,  

когда мы пишем какую-то такую конструкцию, дальше тело следует  

в каких-нибудь скобочках, в «Питоне» для этого используются отступы.  

Отступы должны быть единообразными.  

Вот я здесь просто отступил на Tab, а если мы продолжаем тело,  

то нужно писать опять-таки тоже с отступом.  

Давайте еще что-нибудь напишем и посмотрим,  

что все хорошо, все работает.  

Ok.  

Теперь давайте разберемся с чем-нибудь еще.  

Ну, например, с циклами.  

Циклы встречаются, наверное, почти что в каждой программе.  

И давайте напишем простой цикл, в котором будем выводить числа от 1 до 10.  

For i in range (10), и опять же так же с отступом пишем print i.  

Давайте посмотрим, что получится.  

Ну смотрите.  

Вывелись числа 0, 1, ..., 9.  

То есть такая конструкция приводит к тому, что мы получаем все  

числа от 0 до 9 включая, то есть 10 не входит в этот интервал.  

При этом мы могли бы написать, ну, например, вот таким вот образом,  

и задать первое число.  

Тогда бы мы получили число от 1 до 9, и обратите  

внимание: когда мы делаем print, сразу же происходит перевод на следующую строку.  

Если мы хотим от этого избавиться, мы можем поставить здесь запятую,  

и тогда все это будет выведено через пробелы.  

Теперь давайте  

чуть подробнее изучим, что же такое range.  

Давайте просто сделаем print range от 2 до 5.  

Вот мы видим, что это просто какой-то список.  

И отсюда у нас возникает мысль, что может быть в «Питоне» можно писать каким-нибудь  

таким образом: for i in, давайте прям напишем список, print i.  

На самом деле так и есть, оказывается в «Питоне» циклы у нас устроены не таким  

образом, что мы обязательно в каком-то диапазоне значений пробегаемся,  

а мы просто пробегаемся по какому-нибудь контейнеру с элементами.  

Ну, например, по списку.  

То есть если мы возьмем и посмотрим type от range,  

то мы сразу же обнаружим, что это просто список.  

Сразу расскажу еще одну интересную вещь.  

Мы могли бы написать не range, а xrange,  

ну и то же самое, и увидеть,  

что результат абсолютно тот же.  

Возникает естественный вопрос — а зачем же нужно два способа добиться одного и  

того же результата?  

На самом деле результат не совсем один и тот же.  

Оказывается, если мы посмотрим тип xrange,  

то мы увидим, что xrange имеет тип xrange.  

Ну хорошо.  

Яснее нам не стало, но мы поняли, что это не список.  

Давайте еще напечатаем: xrange, [БЕЗ_ЗВУКА] ну,  

здесь мы видим чуть больше конкретики, но по прежнему остается некоторая загадка.  

Оказывается, xrange — это естественный пример генератора.  

А генератор не представляет из себя сразу готовый список различных значений,  

а генерирует их прямо на ходу.  

То есть у вас в памяти не хранится длинный список,  

как если вы напишите range и какое-то большое число.  

Ну вот, например, так.  

Если вы пишите for i in range от чего-то большого,  

то лучше всё же написать xrange.  

Так, давайте чуть подробнее познакомимся с генераторами,  

но для этого сначала мы изучим вещь, которая называется list comprehension.  

Оказывается, в «Питоне» очень многие вещи можно писать буквально в одну строчку.  

Ну, давайте попробуем вывести числа от 1 до  

10 в массиве, и возведя их в квадрат.  

Можно просто взять написать print, квадратные скобочки,  

и в квадратных скобочках мы прямо пишем — x в квадрате for  

x in range 1 до 10 включительно,  

наверное, давайте выведем, так что 1, 11.  

Нажимаем и видим — да, действительно, результат.  

Ну, теперь давайте попробуем оставить из них только четные.  

Для этого достаточно дописать if x % 2 = 0.  

Дописываем, пожалуйста — остались только четные из них.  

Теперь давайте не будем это выводить на печать, а просто создадим объект,  

который будет равен вот этому всему.  

Сделали, теперь посмотрим тип.  

[БЕЗ_ЗВУКА] Ну,  

как мы видим, тип этого объекта — список, и здесь у нас  

возникает опять же вопрос — а как бы нам сделать не список, а генератор?  

То есть не хранить сразу все эти значения в памяти.  

Оказывается, для этого достаточно заменить квадратные скобочки на круглые,  

давайте посмотрим, что получилось.  

И вот, действительно, тип — генератор.  

Таким образом, range отличается от xrange ровно тем,  

чем в этом выражении отличаются квадратные скобочки от круглых.  

Ну, давайте теперь выясним,  

что у нас есть еще какие-то способы написать цикл.  

Ну, например, давайте скажем, что x = true, а while x,  

заведем какую-нибудь переменную,  

будем внутри цикла ее инкрементировать,  

и if s > 10,  

сделаем break, то есть завершим цикл.  

Ну и давайте всё это будем печатать.  

print s.  

Ну, оказывается, такой цикл тоже можно делать.  

В цикле, да, можно использовать break, можно использовать continue,  

которое приводит сразу же к переходу на следующею итерацию.  

Ну, давайте напишем так: if s %  

2 = = 0, сделаем continue  

и посмотрим, как это отразится на выдаче.  

Угу-угу.  

Ну, вот мы видим, что вроде бы никак существенно не отразилось.  

Давайте попробуем понять, почему.  

[БЕЗ_ЗВУКА] Для  

этого попробую переставить в другое место.  

[БЕЗ_ЗВУКА] Ну и вот видите,  

мы получили нечаянно бесконечный цикл.  

Потому что мы просто проверяем,  

что остаток от деления на 2 равен нулю до того, как изменяем переменную s,  

и это условие у нас выполняется постоянно, и мы всё время делаем continue.  

Давайте проведем исполнение этого кода, вернем обратно.  

[БЕЗ_ЗВУКА] Ну?  

давайте, если это условие выполнилось,  

тоже что-нибудь напишем.  

Вот, смотрите.  

В этой ситуации мы получили следующий эффект.  

Мы просто делаем переход на следующую итерацию,  

в случае если s четное, и ничего не печатаем.  

Почему же в первый раз у нас получилось не совсем так?  

Ну просто вот это выражение у нас было написано после print s,  

поэтому вывод действительно не отличался.  

ну и давайте теперь познакомимся с функциями в Python, допустим,  

нам нужно реализовать, ну, например, свой range.  

Давайте напишем def myrange, пусть,  

опять же будут 2 переменные, a и b,  

от которых зависит результат, и также с отступом пишем return,  

и здесь напишем list comprehension, x for x in...  

ах, нет, тогда нам придется использовать range, наверное, это не очень хорошо.  

Давайте тогда просто создадим список, и напишем for...  

или даже так...  

while s не равно b,  

будем добавлять список с  

помощью метода append (s) и  

увеличивать s на единичку.  

Ну и давайте посмотрим, будет ли это все работать, и как.  

print myrange.  

Ну, вроде похоже на правду.  

Конечно, можно было бы еще подумать о каких-то особых ситуациях, когда мы будем  

давать не совсем подходящие числа на вход, но это не является нашей целью сейчас.  

Сейчас наша цель — просто познакомиться с синтаксисом.  

Синтаксис функций мы уже увидели.  

И давайте напоследок я расскажу еще об одной интересной вещи.  

Оказывается, нам необязательно писать что-то в духе x в квадрате for  

x in range (10), если мы хотим получить квадраты первых 10 чисел.  

Оказывается, тот же результат можно получить с помощью функции map.  

Функция map просто применяет некоторую функцию  

к контейнеру.  

Давайте опять напишем print map.  

Здесь напишем range (10), но какую функцию мы будем применять?  

Нам хочется возводить в квадрат, ну,  

давайте сразу определим функцию возведения в квадрат.  

[ПЕЧАТАЕТ] И  

ее и подставим в map.  

Ну да, так работает,  

но на самом деле есть еще одна удобная вещь,  

можно функции определять прямо на ходу с помощью так называемых λ-выражений.  

Ну, например, мы можем написать map точно так же написать range (10),  

а в качестве первого аргумента напишем следующую вещь: λ,  

дальше пишем переменную, x, дальше двоеточие,  

и пишем то, что нужно возвращать – x в квадрате.  

Посмотрим на результат.  

Да, все так, как нужно.  

Если нам нужно ввести функцию от нескольких переменных,  

то мы можем перечислить их здесь через запятую и использовать их.  

Каким-нибудь вот таким вот образом.  

Ну и здесь, конечно, этот код не заработает,  

потому что у нас подается на вход одна переменная.  

Итак, мы познакомились с основными конструкциями языка Python.  

В следующем видео вы узнаете о том,  

как читать из файла и как записывать файл.  
