Вырезано из https://www.coursera.org/learn/mathematics-and-python/lecture/lsXAR/pandas-indieksatsiia-i-sieliektsiia 

Video Player is loading. 

Play Video 

Loaded: 0% 

00:03 

Progress: 0% 

Current Time 0:03 

/ 

Duration 13:00 

Субтитры 

Отключить субтитры 

Русский 

Качество видео 

Среднее 

Скорость воспроизведения 

1.00x 

Автозапуск 

This is a modal window. 

Beginning of dialog window. Escape will cancel and close the window. 

TextColorTransparencyBackgroundColorTransparencyWindowColorTransparency 

Font SizeText Edge StyleFont Family 

End of dialog window. 

Не удалось отправить. Повторите попытку.Пропустить 

[БЕЗ_ЗВУКА] В этом видео мы продолжаем работать с библиотекой Pandas.  

Мы узнаем еще несколько полезных функций для работы с Data Frame,  

а также поговорим об индексации и селекции.  

Для начала импортируем нашу библиотеку.  

Далее снова создаем Data Frame.  

Делаем это с помощью уже знакомой нам функции  

read.csv [БЕЗ_ЗВУКА]  

[БЕЗ_ЗВУКА]  

Итак, наш Data Frame перед вами.  

Первое, что хочется сделать, это посмотреть, какого типа наши столбцы.  

Это делается с помощью dtypes.  

[БЕЗ_ЗВУКА] Мы видим,  

что все столбцы имеют тип object.  

Если присмотреться повнимательнее к нашему Data Frame, то можно заметить,  

что столбец Birth соответствует дата рождения.  

А в Python есть специальный тип datetime для работы с датами.  

Если мы сделаем наш столбец типа datetime, то нам будет удобнее с ним работать,  

потому что мы сможем вызывать специфичные для datetime функции.  

Это можно сделать с помощью метода Apply.  

Давайте посмотрим, как он работает.  

Сразу скажу, что метод Apply тоже работает не inplace,  

поэтому воспользуемся уже привычным синтаксисом с присваиванием.  

Вызываем метод Apply.  

Итак, что мы хотим?  

Мы хотим применить к нашему столбцу функцию, которая поменяет его тип.  

Вот давайте вызовем функцию to.datetime.  

Это также функция модуля Pandas.  

Так, вызываем нашу функцию.  

И теперь смотрим, как изменился наш Data Frame.  

[БЕЗ_ЗВУКА] Сначала можем просто вывести его на печать.  

Видим, что немножечко изменился формат записи наших дат.  

А теперь убедимся, что тип также изменился.  

Снова высылаем dtypes.  

И видим, что, действительно, колонка Birth изменила свой тип.  

Теперь это datetime, теперь мы сможем с ней работать, как с датой.  

А следующая полезная функция, которую мы изучим, это функция info.  

Она позволяет нам получить мини сводку по нашему Data Frame.  

Мы видим список всех колонок, которые у нас есть, видим,  

сколько там ненулевых объектов.  

Вот мы видим, что в колонке Position есть два нулевых значения.  

Также мы видим, какие типы данных у нас используются,  

и сколько места тратится на хранения нашего Data Frame.  

Мы видим, что наш Data Frame содержит пропущенные значения.  

Это пропуски – столбцы Position.  

Не все должности заполнены.  

Нам не всегда удобно работать с пропущенными значениями в том виде,  

в котором они есть, и часто мы хотим их на что-то заменить и чем-то их заполнить.  

Давайте это сделаем и в нашем случае.  

Например, предположим, что откуда-то из наших опорных данных мы знаем,  

что везде, где позиция пропущена, она соответствует должности «разнорабочий».  

Давайте так и заполним.  

Для этого можем воспользоваться методом Fillna.  

[БЕЗ_ЗВУКА] В  

качестве аргумента передаем то значение, которое мы хотим заполнить наши пропуски.  

Мы с вами просто пишем строчку «разнорабочий».  

И сразу говорим, что мы хотим это делать inplace.  

Итак, запускаем.  

Убираем лишнюю букву «a».  

И еще раз запускаем.  

Теперь давайте посмотрим, как выглядит наш Data Frame после изменений.  

На экране появился Data Frame без пропусков.  

Теперь все наши пропуски заполнены значением «разнорабочий».  

Но на самом деле в данном случае мы видим,  

что наши изменения коснулись только одного столбца.  

Часто нам удобней вывести его отдельно.  

Это можно сделать, обратившись к нему по имени через точку.  

Например frame.Position.  

Видим, что нам вывелся только один столбец.  

Причем он вывелся, как serias, то есть как обычный массив.  

Если мы хотим вывести его в виде Data Frame,  

то есть чтобы было видно саму таблицу, то нужно обратиться к нему несколько иначе.  

Указываем значение нашего столбца, вернее его имя, Position.  

И видим, что теперь он вывелся в привычной для нас форме в виде таблицы.  

На самом деле аналогичным образом можно вывести любой набор столбцов.  

Давайте выведем имя и позицию, Name и Position.  

И аналогично можно поступать со строчками.  

Допустим, мы хотим вывести первые несколько строк.  

Если мы выводим первые строки, то можно воспользоваться командой head.  

Допустим первые 3 строки.  

Есть и альтернативный способ вывода первых трех строк нашего Data Frame.  

Мы можем работать с Frame в данном случае как с простым списком.  

Давайте просто обратимся по индексу.  

Сделаем вот так, и также получим наши первые 3 строки.  

Аналогично можно вывести, там, последние 3 строки.  

Все очень похоже на обычный список.  

Вот так.  

Все работает.  

Если же мы хотим сделать что-то более сложное, например выбрать какой-то  

список строк и какой-то список столбцов, мы можем воспользоваться командой loc.  

Она позволяет обращаться к нашему Data Frame с помощью обращения  

к названиям наших осей.  

Давайте продемонстрируем, как это работает.  

Вызываем loc.  

Дальше сначала передаем ему список тех строк, которые мы хотим.  

Название наших строк – это их индекс.  

Поэтому можем, ну просто, написать список цифр, ну допустим, 1-я, 3-я и 5-а строка.  

Дальше говорим, с какими столбцами мы хотим работать.  

Ну давайте выведем Name, например, и City.  

Теперь видим, что получилось ровно то, что мы хотели: 3 строчки и 2 столбца.  

Альтернативно можно обращаться к нашим осям не по имени,  

а по позиции, то есть по номеру нашего столбца и по номеру нашей строки.  

Это делается с помощью команды iloc.  

[БЕЗ_ЗВУКА] В данном случае первый аргумент не изменится,  

потому что название оси совпадает с ее позициями,  

поэтому просто пишем 1, 3, 5.  

А вот для обращения к колонкам,  

нам придется просто заменить Name и City на их номера.  

Соответственно, это получается, что у нас, у нас получается 0-й и 2-й номер.  

Индексация с 0.  

Да, получили тот же самый срез нашего массива.  

Есть еще один способ обратиться к нашему массиву и сделать выборку.  

Это метод ix.  

Он умеет работать одновременно и с именами, и с позициями.  

Вот давайте проверим.  

Сначала давайте проверим, как он работает с именами.  

Повторим те же аргументы, которые мы передавали методу «loc.  

Соответственно результат должен быть таким же.  

Так, передаем Name и City.  

И запускаем.  

Видим, что выброска не изменилась.  

А теперь давайте попробуем передать туда номера.  

[БЕЗ_ЗВУКА] Да,  

все точно так же.  

Поэтому чаще всего разработчики предпочитают использовать сразу ix,  

потому что он поддерживает и ту, и другую аннотацию.  

Так, на самом деле мы можем делать не только такие простые выгрузки из нашей  

таблицы.  

Мы можем делать более сложные срезы,  

удовлетворяющие некоторым логическим операциям.  

Ну, например, мы можем как-нибудь отфильтровать наш Data Set.  

Давайте возьмем Data Frame и отфильтруем его по дате рождения.  

Например, выберем только тех людей, кто старше 85-го года рождения.  

Как это можно сделать?  

Берем наш Data Frame.  

Берем что нас будет интересовать поле «дата рождения».  

Указываем его в квадратных скобках.  

Дальше записываем явно то логическое выражение, которое мы хотим проверить.  

В данном случае нас интересует «больше,  

либо равно» и давайте будем сравнивать с 85-м годом.  

Нам нужно создать сначала наш datetime объект.  

Помните мы заранее поменяли тип нашего столбца,  

чтобы мы могли работать с ним, как с датами.  

Поэтому теперь, если мы будем сравнивать этот столбец с датой,  

то мы получим корректный результат сравнения.  

Итак, 1 января 85-го года.  

Итак, мы видим, что результат соответствует нашему условию.  

В таблице остались только те сотрудники, дата рождения которых не раньше,  

чем 1 января 1985 года.  

Работает это с помощью логических индексов.  

Чуть подробнее, что это такое, вы узнаете несколько позже,  

когда будете изучать библиотеку NumPy.  

Там вы обязательно познакомитесь с этим понятием.  

Но а сейчас мы двигаемся дальше.  

И давайте мы несколько усложним наше условие.  

Сейчас мы проверяли условие только на один столбец, давайте проверим сразу несколько.  

Так как результат применения нашего условия к столбцу логический,  

то есть True или Falce для каждой строки, то на самом деле мы можем применить  

некоторую логическую функцию между различными условиями.  

Например, мы можем проверить условие на дату рождения,  

еще одно условие на дату рождения или на какой-то другой столбец, и посмотреть,  

скажем, на их пересечение или на их объединение.  

Любую логическую функцию.  

Вот давайте сначала возьмем некоторое условие на дату рождения.  

Даже давайте оставим то же самое и проверим условие на город.  

Например, выберем только сотрудников, которые не из Москвы.  

Вот синтаксически это будет выглядеть следующим образом: снова берем наш Frame,  

и в квадратных скобках записываем условия.  

Так как условия будет два,  

давайте сразу подготовим круглые скобки для каждого из условий.  

И так как мы уже договорились, что будем использовать их пересечение,  

давайте добавим знак логического «и» между ними.  

Теперь первое условие оставляем без изменений.  

Дата рождения.  

Дата рождения должна быть не раньше, чем 1-го января.  

[БЕЗ_ЗВУКА]  

[БЕЗ_ЗВУКА] И  

следующее условие давайте выберем таким: «город» ≠ «Москва».  

[БЕЗ_ЗВУКА] Судя по предыдущей таблице, мы ожидаем получить только одну строчку.  

Давайте посмотрим.  

Ровно так и получилось.  

Это было пересечение условий.  

А теперь давайте попробуем сделать объединение условий.  

То есть логическое «или».  

Синтаксис будет очень похож.  

Сначала записываем первое условие.  

Давайте снова его оставим.  

[БЕЗ_ЗВУКА]  

[БЕЗ_ЗВУКА] Дальше набираем знак логического «или».  

И запишем второе условие.  

Давайте выберем тех людей, которые из Волгограда.  

[БЕЗ_ЗВУКА]  

Запускаем нашу команду и видим,  

что у нас появилось два типа людей: первые те, у кого «город» = «Волгограду», это  

первый человек, и все остальные, у кого дата рождения позже 1 января 85-го года.  

На этом мы закончим работу с Data Frame.  

Вы уже научились создавать Data Frame, модифицировать их,  

применять к ним различную функцию, работать с индексами и делать выборки.  

На самом деле это только вершина айсберга, но нам пора двигаться дальше,  

и в следующей видеолекции вы будете изучать библиотеку NumPy.  
