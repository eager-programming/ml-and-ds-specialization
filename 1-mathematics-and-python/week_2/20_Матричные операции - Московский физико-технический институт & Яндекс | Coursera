Вырезано из https://www.coursera.org/learn/mathematics-and-python/lecture/8rcWr/matrichnyie-opieratsii 

This is a modal window. 

Beginning of dialog window. Escape will cancel and close the window. 

TextColorTransparencyBackgroundColorTransparencyWindowColorTransparency 

Font SizeText Edge StyleFont Family 

End of dialog window. 

[БЕЗ_ЗВУКА] В  

это видео мы поговорим о том, какие операции можно вводить над матрицами.  

В прошлый раз мы уже разобрались с вами, как умножать матрицу на вектор.  

А именно: мы можем умножать матрицу размера m × n на вектор-столбец  

размера n × 1.  

Для этого мы домножаем каждый элемент i-той строки на соответствующий элемент  

вектора и складываем.  

В итоге получаем i-тый элемент вектора-результата.  

Получаем мы на выходе вектор размера m × 1.  

Обратите внимание, мы могли умножать матрицу на вектор только в том случае,  

если число столбцов в матрице совпадало с длиной вектора.  

Иначе операция была не определена.  

Давайте теперь поговорим о том,  

как ввести более общую операцию — умножение матрицы на матрицу.  

Она будет возможна только в том случае, если число столбцов в первой матрице  

совпадает с числом строк во второй матрице.  

Иначе эта операция будет не определена, делать её будет невозможно.  

Итак.  

Пусть есть две матрицы — A и B.  

Матрица A имеет размер m × n, а матрица B имеет размер n × k.  

Результатом будет матрица C размера m × k.  

То есть строк в ней будет столько же, сколько в первой матрице,  

а столбцов столько же, сколько во второй.  

Чтобы перемножить матрицы A и B и получить C, мы делаем следующее:  

i-тый j-тый элемент матрицы C получается поэлементным умножением  

i-той строки матрицы A на j-тый столбец матрицы B, что затем складывается.  

Именно так и получается матрица C.  

Давайте разберём пример.  

Пусть есть две матрицы, первая имеет размер 3 × 2, вторая 2 × 3.  

Результатом будет матрица размера 3 × 3.  

Давайте получим её элемент с индексами 1, 1.  

Для этого нам понадобится первая строка матрицы A и первый столбец матрицы B.  

Перемножаем их.  

Получаем 1 * 1 + 2 * 0.  

Значит, элемент с индексами 1, 1 матрицы C будет равен 1.  

Посчитаем элемент с индексами 1, 2.  

Для этого мы умножаем 1 на 0 и 2 на 0 и складываем.  

Получаем 0.  

Чтобы получить элемент с индексами 1, 3, умножаем 1 на 0,  

прибавляем 2 * 2, получаем 4.  

Наконец, чтобы получить элемент с индексом 2, 1, умножаем 0 на 1, 1 на 0, получаем 0.  

И так далее.  

У вас, наверное,  

уже возник вопрос: почему мы ввели операцию умножения матриц именно так?  

Эта формула не кажется интуитивной, она не приходит в голову в первую очередь.  

Но, оказывается, у неё есть довольно понятный глубокий смысл.  

Давайте попробуем его понять.  

Мы уже выясняли, что матрица, по сути, задаёт линейное преобразование,  

линейную функцию из одного векторного пространства в другое.  

То есть, по сути, она принимает на вход один вектор и возвращает другой,  

уже другой разрядности.  

Например, матрица A может задавать преобразование из пространства V в  

пространство W,  

а матрица B — задавать преобразование из пространства W в пространство T.  

Поскольку это функции, можем определить их композицию, B от A, то есть сначала к  

вектору из пространства V применяем преобразование A, потом преобразование B,  

и в итоге вектор из пространства V переходит в пространство T.  

При этом оказывается, если мы перемножим матрицы B и A, то полученное произведение  

BA будет как раз задавать преобразование из пространства V в пространство T,  

ровно то преобразование, которое является композицией B и A.  

Это одна из главных причин, почему умножение вводится именно так.  

Есть ещё одна причина.  

Представьте, что у нас есть некоторая система линейных уравнений Ax = b.  

Например, это может быть задача поиска линейного  

классификатора для предсказания возникновения рака.  

В этом случае в строках A записаны пациенты, для каждого пациента известно,  

какие мутации имеют место в его геноме,  

а в B записан правильный ответ: возникнет рак через 5 лет или не возникнет.  

Тогда x — это веса, с которыми складываются индикаторы наличия мутации в  

геноме, и получается некоторый ответ.  

При этом, на самом деле, x может тоже выражаться через другой вектор z,  

то есть может иметь место уравнение x = Bz.  

Откуда оно может быть?  

Оно может задавать некоторые дополнительные ограничения.  

Например, что две определённые мутации должны носить одинаковый вклад в принятие  

решения, то есть должны иметь одинаковый вес.  

Это всё можно отрегулировать матрицей B.  

В итоге получается, что нужно решать систему вида A*(Bz) = b.  

Так вот.  

Оказывается, что если мы поставим выражение  

для вектора x, то есть x = Bz, в первое уравнение,  

раскроем скобки, сгруппируем и получим уравнение относительно z,  

то мы получим систему с матрицей, которая будет равняться произведению A и B.  

То есть мы ввели умножение так, чтоб можно было подставлять одну систему линейных  

уравнений в другую, и при этом всё сохранялось.  

Хорошо.  

Давайте поговорим о более простых операциях — сложение и умножение на число.  

Здесь всё гораздо более интуитивно.  

Чтобы сложить две матрицы, мы должны убедиться,  

что они имеют одинаковый размер.  

То есть обе имеют размерность m × n, иначе сложение не определено.  

Складываем мы поэлементно.  

То есть i-тый j-тый элемент матрицы C суммы A и B будет равняться aij + bij.  

Всё очень просто.  

То же самое касается умножения на число.  

Чтобы умножить матрицу b на некоторое число α,  

просто умножаем на α каждый элемент.  

То есть cij — результат — будет равен α * bij.  

Наконец, поговорим о такой операции, как транспонирование.  

Мы будем с ней сталкиваться довольно часто.  

Для этого нам понадобится понятие главной диагонали.  

Пусть есть некая матрица A размера 4 × 3.  

Главной диагональю называются все её элементы,  

у которых первый индекс равен второму, то есть все элементы вида aii.  

В нашем случае, это будет элемент (1, 1), (2, 2) и (3,  

3), которые имеют значения 1, 3 и 0.  

Это действительно диагональ.  

Транспонирование — это, по сути, поворот относительно главной диагонали.  

Матрица A размера m × n превращается в матрицу A транспонированное размера n × m.  

Кстати, A транспонированное обозначается как A с верхним индексом T.  

Иными словами, i-тый j-тый элемент транспонированной  

матрицы равен j-тому i-тому элементу исходной матрицы.  

Ещё можно интерпретировать это так,  

что строки исходной матрицы становятся столбцами транспонированной матрицы.  

Вернёмся к нашему примеру.  

Матрица размера 4 × 3 становится матрицей 3 × 4, при этом главная диагональ 1,  

3, 0 остаётся на своём месте, а всё остальное поворачивается относительно неё.  

То есть, например, столбец 1,  

2, 2 ,5 (первый столбец) становится первой строкой 1, 2, 2, 5.  

И так далее.  

Итак.  

Что мы узнали?  

Умножение матриц — это довольно хитрая операция,  

которая при этом имеет довольно глубокий смысл.  

Например, она соответствует композиции двух линейных преобразований  

или соответствует постановке в систему линейных уравнений вектора,  

который тоже выражается как матрица умножить на вектор.  

При этом сложение и умножение для матриц (умножение на константу) определяется  

интуитивно, просто поэлементно.  

Также мы изучили с вами транспонирование — это операция,  

которая меняет строки и столбцы матрицы местами.  

В следующем видео мы поговорим о том, что такое ранг и определитель.  
