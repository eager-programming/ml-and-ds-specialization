Вырезано из https://www.coursera.org/learn/mathematics-and-python/lecture/rcjAW/pandas-data-frame 

This is a modal window. 

Beginning of dialog window. Escape will cancel and close the window. 

TextColorTransparencyBackgroundColorTransparencyWindowColorTransparency 

Font SizeText Edge StyleFont Family 

End of dialog window. 

[БЕЗ_ЗВУКА] В этом видео мы начнем знакомство с библиотекой Pandas.  

Pandas — очень мощный инструмент для анализа данных Python.  

Pandas позволяет нам работать с данными в виде таблиц.  

Это очень естественное представление данных в задачах анализа.  

Например, если мы решаем задачу классификации данных,  

то часто мы работаем с матрицей «объект-признак».  

В этом случае по строчкам у нас идут объекты, а по столбцам — их признаки.  

Опять же, если мы решаем задачу построения рекомендательных систем,  

снова мы работаем с таблицами.  

Мы работаем с таблицей User right, ну или с матрицей предпочтения.  

Итак, переходим к нашей библиотеке.  

Сначала нам нужно ее импортировать.  

Делаем это с помощью команды import.  

[ПЕЧАТАЕТ] Я использую  

стандартное сокращение pd, вы будете часто это встречать в коде.  

Итак, основное в структуре данных, которое позволяет нам работать с таблицами,  

является Data Frame.  

Data Frame можно представлять себе как такую двумерную матрицу или как dict-like  

container для работы c Series.  

Series — это обычный одномерный drr массив, он отличается от простого массива  

только тем, что в простом массиве у нас все элементы проиндексированы от  

0 до размера массива −1, а тут у нас элементы могут иметь лейблы,  

то есть это могут быть, в принципе, произвольные имена.  

Итак, создадим нашу первую таблицу, или наш первый DataFrame.  

Сделаем это с помощью словаря.  

Пусть наш DataFrame состоит всего лишь из двух столбцов.  

Первый столбец будет числами, второй столбец будет  

каким-нибудь повторяющимся символом.  

Ну так, теперь создаем наш словарь.  

[ПЕЧАТАЕТ]  

[ПЕЧАТАЕТ] Итак, мы сделали табличку,  

теперь давайте выведем ее на экран и посмотрим, как она выглядит.  

Итак, мы видим, что названия столбцов соответствуют  

нашим ключам в словаре, и значения соответствуют тому, чем мы их заполнили.  

Довольно удобно.  

Но на самом деле такой способ создания DataFrame будет использоваться не так  

часто, потому что обычно мы хотим анализировать какие-то внешние данные,  

а эти данные часто хранятся в виде файлов или в виде набора файлов.  

Поэтому нам удобнее будет считывать эти данные в DataFrame и дальше работать с  

ними, как с таблицами.  

Вот давайте попробуем такое сделать.  

Для этого есть функция read_csv.  

Она позволяет нам считывать данные с каким-то стандартным разделителем  

и далее работать с ними, как с таблицей.  

Создадим новый объект и считаем на него специально заготовленный файл.  

[ПЕЧАТАЕТ] В качестве первого аргумента передаем имя этого файла.  

[ПЕЧАТАЕТ] Дальше нам нужно указать, есть ли в нашем файле заголовки.  

В нашем файле они есть, они находятся в первой строчке.  

И дальше нужно написать, какой разделитель у нас используется.  

В данном случае мы используем табуляцию.  

Итак, мы считали наш файл в таблицу, давайте на него посмотрим.  

[ПЕЧАТАЕТ] Видим,  

что получилась небольшая табличка.  

Она состоит из шести строк и четырех столбцов.  

Наши столбцы имеют имена (они перед вами в верхней строчке),  

и строки опять проиндексированы.  

Кстати, чтобы обратиться к именам столбцов или чтобы их поменять,  

есть специальный атрибут, называется columns.  

Таким образом, можно к нему обратиться через точку.  

И вот мы видим все наши имена столбцов.  

Также довольно полезный атрибут – shape.  

С помощью него можно посмотреть на размер нашей таблицы.  

Ну сейчас табличка маленькая, мы и так представляем себе ее размеры,  

а когда таблица довольно большая, то это полезно.  

[ПЕЧАТАЕТ] Итак,  

мы научились создавать DataFrame, а теперь давайте потренируемся их модифицировать.  

Мы можем удалять и добавлять строчки, удалять и добавлять столбцы.  

Давайте начнем с простого и добавим в конец нашего DataFrame новую строчку.  

Строчку будем добавлять в виде словаря.  

Это далеко не единственный способ добавления строки, но он довольно простой.  

Для начала давайте создадим такой словарь.  

Назовем его new_line, потому что он будет являться впоследствии новой линией в  

нашем DataFrame, в нашей таблице.  

Ну и давайте заполним какие-нибудь значения.  

Допустим, заполним имя.  

Ну давайте еще заполним дату рождения.  

Ну вот можно еще заполнить город.  

[ПЕЧАТАЕТ] Итак, наш словарь готов.  

Теперь с помощью команды append нужно его добавить к нашему DataFrame.  

Вызываем во frame метод append.  

В качестве первого аргумента передаем наш словарь.  

И еще указываем аргумент ignore_index = True,  

потому что нам не так важно, под каким индексом добавится наша новая строчка.  

Так, сделали команду,  

видим что в конце DataFrame добавилась новая 6-я строка с тем, что мы заполнили.  

Давайте еще раз выведем на печать наш DataFrame.  

Так.  

Видим, что здесь этих изменений нет.  

Почему это произошло?  

Ну потому что команда append, на самом деле, работает не inplace,  

то есть она никак не изменяет наш исходный DataFrame.  

Она вносит нужные изменения и возвращает нам его копию.  

Если же мы хотим, чтобы наш DataFrame изменился,  

то нужно немножечко модифицировать нашу команду.  

Ну опять же, как вариант можно сделать вот так.  

Тогда, если мы снова выведем на печать наш DataFrame, то увидим, что он изменился.  

Действительно добавилась новая строчка.  

Теперь давайте добавим новые столбцы.  

Это делается довольно просто, потому что наш DataFrame можно  

представлять себе как такой словарь Series.  

Если мы добавляем новый объект к словарю, то как мы делаем?  

Мы просто указываем значение нового ключа и добавляем объект.  

Вот давайте здесь поступим по аналогии.  

Итак, пишем его название.  

И дальше более-менее случайно давайте его заполним.  

[ПЕЧАТАЕТ] Итак, готово.  

Выводим наш DatаFrame на экран и видим,  

что добавился новый столбец.  

Так, с добавлением более-менее разобрались.  

Теперь давайте что-нибудь удалим.  

Ну сначала можно удалить некоторые строчки.  

Вот давайте последние две строки удалим.  

Для этого существует команда drop.  

Сначала указываем, какие именно объекты мы удаляем.  

Если мы удаляем строчки, то нам нужно указывать название индекса.  

Ну то есть названия этой оси.  

Так, ну вот смотрим: давайте удалим две последних строки, у них номера 5 и 6.  

Указываем, что эти номера мы указываем по оси 0, и запускаем.  

Видим, что наш DataFrame стал на 2 строки короче.  

Но в drop есть такая же особенность, как и у функции append.  

Она тоже работает не inplace.  

Поэтому если мы еще раз выведем на экран наш DataFrame, то мы обнаружим,  

что все строчки на месте.  

Чтобы это поправить, нужно в предыдущей команде добавить аргумент inplace = True.  

Но если мы действительно хотим удалить эти строчки из исходного DataFrame.  

Итак, запускаем и проверяем: действительно строчки удалились.  

Аналогично можно удалить столбцы.  

Здесь нам снова понадобится функция drop.  

Только в данном случае нам нужно будет обращаться уже не к индексам,  

а к именам наших столбцов.  

Вот давайте удалим тот столбец, который мы с вами недавно создали.  

Мы обращаемся к нему по имени.  

Так, только обратиться нужно правильно, иначе ничего не получится.  

Так, дальше указываем, что мы работаем с осью 1.  

Ну и давайте тоже сделаем это сразу inplace.  

[ПЕЧАТАЕТ] Так, готово.  

Выводим наш DataFrame на экран и видим, что все получилось.  

Наш столбец пропал.  

Часто, после того, как мы проделываем какие-то манипуляции с DataFrame, например  

чистим данные, добавляем новые столбцы, вычисляем какие-то новые значения,  

нам хочется сохранить результат в виде файла, чтобы в дальнейшем с ним работать.  

Pandas позволяет нам сделать это с помощью простого метода.  

Он называется to_csv.  

Давайте запишем наш новый получившийся DataFrame в файл.  

Для этого вызываем эту функцию — to_csv.  

И давайте теперь аккуратненько запишем, заполним ее аргументы.  

Для начала нужно написать название файла,  

в который мы хотим сохранить наш DataFrame.  

[ПЕЧАТАЕТ] Ну  

давайте придумаем какое-нибудь простое название — updated_dataset.  

Дальше у нас есть очень много свободы в том,  

как именно мы будем сохранять наш файл.  

Например, мы можем выбрать другой сепаратор, не тот, который был изначально.  

Вот давайте для разнообразия теперь укажем запятую.  

Дальше мы можем решать, хотим ли мы оставить header в нашем файле.  

Ну давайте оставим.  

Напишем header = True.  

И то же самое можно сделать с индексами.  

В данном случае индекс нам не очень полезен,  

поэтому давайте записывать его не будем.  

Напишем, что индекс нам не нужен.  

Так, запускаем команду.  

И теперь давайте убедимся, что наш файл выглядит именно так, как мы ожидаем,  

— наш DataFrame через запятую, с заголовком и без индекса.  

Сделаем это с помощью команды cat.  

Так, теперь нужно написать название нашего  

файла: updated_  

dataset.csv.  

Так, значит, где-то мы опечатались.  

Так. Ну вот так получше.  

Видим, что действительно в первой строчке идут header, дальше идет наша таблица,  

все данные через запятую.  

Ровно то, что мы хотели.  

На этом мы заканчиваем наше первое знакомство с Pandas.  

А на следующем видео мы продолжим говорить о DataFrame.  

Мы изучим еще несколько полезных функций и научимся работать с индексами.  

Также мы будем делать выборки из таблиц.  
